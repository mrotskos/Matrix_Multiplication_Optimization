Ανεβάστε τις απαντήσεις σε μορφή PDF. Παρακαλώ παραδώστε τη δική σας προσπάθεια κι όχι αντίγραφο δουλειάς άλλων.

Ο βαθμός από αυτό το κουίζ θα αντικαταστήσει βαθμό προηγούμενης εργασίας (αν δεν την έχετε κάνει ή αν δεν είναι το ίδιο καλή). Ακόμα κι αν δεν τον χρειάζεστε τον βαθμό ξεφυλλίστε την, έχει ενδιαφέρον να δείτε πως αλλάζει η απόδοση με μικρές αλλαγές στον πηγαίο κώδικα.

 

Χρήση ιεραρχίας μνήμης
Σε αυτή την άσκηση θα δούμε πως μπορεί να αλλάξει κώδικας που μαθηματικά είναι ισοδύναμος αλλά στην πράξη η απόδοση του είναι διαφορετική.

Θα χρησιμοποιήσουμε τον πολλαπλασιασμό πινάκων ως παράδειγμα.

C
/*
 * matrixMult - Matrix multiplication
 */
void matrixMult(float * const C,            /* output matrix */
                float const * const A,      /* first matrix */
                float const * const B,      /* second matrix */
                int const n) {              /* number of rows/cols */

  for (int i = 0; i < n; i++) {             /* rows */
    for (int j = 0; j < n; j++) {           /* cols */

      /* initialize output value */
      C[ sub2ind(i,j,n) ] = 0;

      for (int k = 0; k < n; k++) {         /* accumulate products */
        C[ sub2ind(i,j,n) ] +=
          A[ sub2ind(i,k,n) ] * B[ sub2ind(k,j,n) ];
      }
      
    }
  }
      
} // end function 'matrixMult'
όπου sub2ind είναι ένα macro που υπολογίζει τη θέση του στοιχείου [i,j] σε τετραγωνικό πίνακα nxn.

Μετράμε το χρόνο με ακρίβεια με τη χρήση της ρουτίνας gettimeofday(). Επαναλαμβάνουμε το πείραμα αρκετές φορές για να παρατηρήσουμε αν και πότε σταθεροποιούνται οι χρόνοι.

C
    double time = 0.0;
    /* compute matrix multiplication */
    for (int it = 0; it < MAX_ITER; it++) {
      gettimeofday(&start, NULL);
      matrixMult( C, A, B, n );
      gettimeofday(&end, NULL);

      time = ( (end.tv_sec  - start.tv_sec)  * 1000.0 +  /* sec to ms */
               (end.tv_usec - start.tv_usec) / 1000.0 ); /* us to ms */
               
      fprintf("Iter: %d Time: %f\n", it, time);
    }


Βήμα 0. Προετοιμασία
Εγκαταστείστε gcc, μεταγλωττίστε με βελτιστοποίηση -Ο3 και τρέξτε τον παραπάνω κώδικα στον υπολογιστή σας για n = 2048 και 10 επαναλήψεις.

Σημειώστε τα παρακάτω

Επεξεργαστής:
Συχνότητα επεξεργαστή:
Μέγεθος μνήμης L1:
Μέγεθος μνήμης L2:
Μέγεθος μνήμης L3:
Μέγεθος μνήμης RAM:
Έκδοση gcc:
Έκδοση Λειτουργικού Συστήματος:
Πόσο διαφοροποιούνται οι χρόνοι στις επαναλήψεις;

Βήμα 1. Αναδιάταξη βρόγχων
Η υλοποίηση που σας δώσαμε είναι η ijk γιατί αυτή είναι η σειρά των τριών βρόγχων που υπολογίζουν το γινόμενο πινάκων. Ετοιμάστε και επαναλάβετε το βήμα 0 για όλες τις δυνατές διατάξεις των τριών βρόγχων. Ποια διάταξη είναι η πιο αποδοτική; Χρησιμοποιείστε το διάμεσο χρόνο των επαναλήψεων ως κριτήριο.

Πόσο πιο γρήγορη είναι η βέλτιστη διάταξη βρόγχων σε σχέση με τη ijk στο Βήμα 0 (λόγος διάμεσων χρόνων);

 

Βήμα 2. Λειτουργία ανά μπλοκ
Ένας βρόγχος for (int i = 0; i < n; i++) μπορεί να διασπαστεί σε δύο για μπλοκ μεγέθους s. Στα παρακάτω υποθέτουμε ότι πάντα το n είναι πολλαπλάσιο του s, για να είναι ο κώδικας μας απλουστευμένος

Τον εξωτερικό for (int i_out = 0; i_out < n; i_out += s)
Τον εσωτερικό for (int i_in = 0; i_in < s; i_in++)
Οι αναφορές στο δείκτη i αντικαθιστώνται από i_out + i_in. 

Να αντικατασταθούν όλοι οι αρχικοί βρόγvχοι με τους διασπασμένους. Πλέον οι δυνατές διατάξεις είναι πολλές. Επιλέξτε τη πιο γρήγορη διάταξη από το βήμα 1, και βάλτε με την ίδια σειρά όλους τους εξωτερικούς βρόγχους και μετά με την ίδια σειρά όλους τους εσωτερικούς βρόγχους. Προσοχή να μη χάσουμε την ορθότητα του κώδικα, δεν έχει νόημα να μετράμε απόδοση για κώδικα που παράγει σκουπίδια. 

Δοκιμάστε για s = 2, 4, 8. Πόσο πιο γρήγορη είναι η βέλτιστη επιλογή s σε σχέση με τη ijk από το Βήμα 0 (λόγος διάμεσων χρόνων);

 

Βήμα 3. Ξεδίπλωμα του εμφωλευμένου βρόγχου
Αντικαταστείστε τον εμφωλευμένο βρόγχο με αντίγραφο από τις εντολές που εκτελεί και την αντίστοιχη τιμή του μετρητή του. 

Πχ αν είχαμε

C
    for (int it = 0; it < 4; it++) {
      fprintf("Iter: %d\n", it);
    }
θα μετατραπεί σε

C

      fprintf("Iter: %d\n", 0);
      fprintf("Iter: %d\n", 1);
      fprintf("Iter: %d\n", 2);
      fprintf("Iter: %d\n", 3);
    
Πόσο πιο γρήγορη είναι η βέλτιστη έκδοση με ξεδιπλωμένο τον εμφωλευμένο βρόγχο σε σχέση με τη ijk από το Βήμα 0 (λόγος διάμεσων χρόνων);